"""
Documentation and Communication MCP Tools
CEO-focused tools for creating specs, managing tasks, and coordinating team work.
"""

import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Optional
from .base_mcp import BaseMCPTool, MCPToolError, openai_function


class DocumentationMCP(BaseMCPTool):
    """
    Documentation and communication tools for CEO strategic coordination.

    Focus: Creating specifications, managing TODO lists, documenting decisions,
    preparing work for future specialist agents.
    """

    async def _execute_action(self, action: str, **kwargs) -> Any:
        """Execute documentation action."""
        action_map = {
            "create_specification": self.create_specification,
            "update_todo_list": self.update_todo_list,
            "get_todo_list": self.get_todo_list,
            "document_decision": self.document_decision,
            "create_team_task": self.create_team_task,
            "get_team_tasks": self.get_team_tasks,
            "update_project_status": self.update_project_status,
            "get_project_status": self.get_project_status,
            "create_progress_report": self.create_progress_report,
            "add_team_message": self.add_team_message,
            "get_team_messages": self.get_team_messages,
            "create_technical_requirements": self.create_technical_requirements
        }

        if action not in action_map:
            raise MCPToolError(f"Unknown action: {action}")

        return await action_map[action](**kwargs)

    @openai_function("create_specification", "Create detailed specification for future development", {
        "type": "object",
        "properties": {
            "title": {"type": "string", "description": "Specification title"},
            "description": {"type": "string", "description": "Detailed description"},
            "requirements": {"type": "array", "items": {"type": "string"}, "description": "List of requirements"},
            "spec_type": {"type": "string", "description": "Type of spec (feature, api, database, etc.)", "default": "feature"}
        },
        "required": ["title", "description", "requirements"]
    })
    async def create_specification(self, title: str, description: str,
                                 requirements: List[str], spec_type: str = "feature") -> Dict[str, Any]:
        """
        Create detailed specification for future development.

        Args:
            title: Specification title
            description: Detailed description
            requirements: List of requirements
            spec_type: Type of spec (feature, api, database, etc.)

        Returns:
            Created specification details
        """
        try:
            # Create filename from title
            filename = f"{title.lower().replace(' ', '_').replace('/', '_')}_spec.md"
            spec_path = self.docs_path / filename

            # Create specification content
            spec_content = f"""# {title} Specification

**Type:** {spec_type}
**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC
**Author:** CEO Agent

## Overview

{description}

## Requirements

"""
            for i, req in enumerate(requirements, 1):
                spec_content += f"{i}. {req}\n"

            spec_content += f"""

## Technical Considerations

- Implementation approach: TBD (to be determined by specialist agents)
- Dependencies: TBD
- Testing requirements: TBD
- Performance considerations: TBD

## Success Criteria

- [ ] Requirements fulfilled
- [ ] Tests passing
- [ ] Documentation updated
- [ ] Code reviewed

## Implementation Notes

*This section will be filled by the development team*

---

*Generated by CEO Agent for team coordination*
"""

            # Write specification file
            with open(spec_path, 'w', encoding='utf-8') as f:
                f.write(spec_content)

            # Log the activity
            self.log_activity("specification_created", {
                "title": title,
                "spec_type": spec_type,
                "file_path": filename,
                "requirements_count": len(requirements)
            })

            # Also add to team tasks
            await self.create_team_task(
                title=f"Implement: {title}",
                description=f"See specification: {filename}",
                task_type="development",
                priority="medium",
                assigned_to="TBD"
            )

            return {
                "title": title,
                "file_path": filename,
                "spec_type": spec_type,
                "requirements_count": len(requirements),
                "created_at": datetime.now().isoformat()
            }

        except Exception as e:
            self.log_activity("create_spec_error", {"title": title, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to create specification: {str(e)}")

    async def update_todo_list(self, items: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Update the main TODO list for the project.

        Args:
            items: List of todo items with title, description, priority, status

        Returns:
            Updated TODO list info
        """
        try:
            todo_file = self.memory_path / "shared" / "todo_list.json"

            # Load existing todos if file exists
            existing_todos = []
            if todo_file.exists():
                try:
                    with open(todo_file, 'r') as f:
                        data = json.load(f)
                        existing_todos = data.get("items", [])
                except:
                    pass

            # Add new items to existing todos
            for item in items:
                todo_item = {
                    "id": len(existing_todos) + 1,
                    "title": item["title"],
                    "description": item.get("description", ""),
                    "priority": item.get("priority", "medium"),
                    "status": item.get("status", "pending"),
                    "created_at": datetime.now().isoformat(),
                    "updated_at": datetime.now().isoformat()
                }
                existing_todos.append(todo_item)

            # Save updated todo list
            todo_data = {
                "updated_at": datetime.now().isoformat(),
                "total_items": len(existing_todos),
                "items": existing_todos
            }

            with open(todo_file, 'w') as f:
                json.dump(todo_data, f, indent=2)

            self.log_activity("todo_list_updated", {
                "new_items_added": len(items),
                "total_items": len(existing_todos)
            })

            return {
                "items_added": len(items),
                "total_items": len(existing_todos),
                "file_path": "memory/shared/todo_list.json"
            }

        except Exception as e:
            self.log_activity("update_todo_error", {"error": str(e)}, "error")
            raise MCPToolError(f"Failed to update TODO list: {str(e)}")

    @openai_function("get_todo_list", "Get current TODO list with optional status filtering", {
        "type": "object",
        "properties": {
            "status_filter": {"type": "string", "description": "Filter by status (pending, in_progress, completed)", "enum": ["pending", "in_progress", "completed"]}
        }
    })
    async def get_todo_list(self, status_filter: Optional[str] = None) -> Dict[str, Any]:
        """
        Get current TODO list.

        Args:
            status_filter: Filter by status (pending, in_progress, completed)

        Returns:
            Current TODO list
        """
        try:
            todo_file = self.memory_path / "shared" / "todo_list.json"

            if not todo_file.exists():
                return {
                    "items": [],
                    "total_items": 0,
                    "message": "No TODO list found"
                }

            with open(todo_file, 'r') as f:
                data = json.load(f)

            items = data.get("items", [])

            # Apply status filter if specified
            if status_filter:
                items = [item for item in items if item.get("status") == status_filter]

            return {
                "items": items,
                "total_items": len(items),
                "last_updated": data.get("updated_at"),
                "filtered_by": status_filter
            }

        except Exception as e:
            self.log_activity("get_todo_error", {"error": str(e)}, "error")
            raise MCPToolError(f"Failed to get TODO list: {str(e)}")

    @openai_function("document_decision", "Document a strategic or technical decision", {
        "type": "object",
        "properties": {
            "title": {"type": "string", "description": "Decision title"},
            "description": {"type": "string", "description": "What was decided"},
            "rationale": {"type": "string", "description": "Why this decision was made"},
            "impact": {"type": "string", "description": "Expected impact of the decision"},
            "alternatives_considered": {"type": "array", "items": {"type": "string"}, "description": "Other options that were considered"}
        },
        "required": ["title", "description", "rationale", "impact"]
    })
    async def document_decision(self, title: str, description: str, rationale: str,
                               impact: str, alternatives_considered: List[str] = None) -> Dict[str, Any]:
        """
        Document a strategic or technical decision.

        Args:
            title: Decision title
            description: What was decided
            rationale: Why this decision was made
            impact: Expected impact of the decision
            alternatives_considered: Other options that were considered

        Returns:
            Decision documentation result
        """
        try:
            decisions_file = self.memory_path / "ceo" / "decisions.md"

            # Read existing decisions if file exists
            existing_content = ""
            if decisions_file.exists():
                with open(decisions_file, 'r') as f:
                    existing_content = f.read()

            # Create new decision entry
            decision_entry = f"""
## {title}

**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC

**Decision:** {description}

**Rationale:** {rationale}

**Expected Impact:** {impact}
"""

            if alternatives_considered:
                decision_entry += "\n**Alternatives Considered:**\n"
                for alt in alternatives_considered:
                    decision_entry += f"- {alt}\n"

            decision_entry += "\n---\n"

            # Append to decisions file
            with open(decisions_file, 'w') as f:
                f.write(existing_content + decision_entry)

            # Also log as structured data
            decision_data = {
                "title": title,
                "description": description,
                "rationale": rationale,
                "impact": impact,
                "alternatives": alternatives_considered or [],
                "timestamp": datetime.now().isoformat()
            }

            # Save to structured decisions log
            decisions_log = self.memory_path / "ceo" / "decisions.jsonl"
            with open(decisions_log, 'a') as f:
                f.write(json.dumps(decision_data) + "\n")

            self.log_activity("decision_documented", {
                "title": title,
                "impact": impact
            })

            return {
                "title": title,
                "documented_at": datetime.now().isoformat(),
                "file_path": "memory/ceo/decisions.md"
            }

        except Exception as e:
            self.log_activity("document_decision_error", {"title": title, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to document decision: {str(e)}")

    @openai_function("create_team_task", "Create task for future team agents", {
        "type": "object",
        "properties": {
            "title": {"type": "string", "description": "Task title"},
            "description": {"type": "string", "description": "Detailed task description"},
            "task_type": {"type": "string", "description": "Type of task (development, testing, documentation, etc.)"},
            "priority": {"type": "string", "description": "Task priority", "enum": ["low", "medium", "high", "urgent"], "default": "medium"},
            "assigned_to": {"type": "string", "description": "Which agent type should handle this", "default": "TBD"},
            "estimated_hours": {"type": "integer", "description": "Estimated work hours"}
        },
        "required": ["title", "description", "task_type"]
    })
    async def create_team_task(self, title: str, description: str, task_type: str,
                              priority: str = "medium", assigned_to: str = "TBD",
                              estimated_hours: Optional[int] = None) -> Dict[str, Any]:
        """
        Create task for future team agents.

        Args:
            title: Task title
            description: Detailed task description
            task_type: Type of task (development, testing, documentation, etc.)
            priority: Task priority (low, medium, high, urgent)
            assigned_to: Which agent type should handle this
            estimated_hours: Estimated work hours

        Returns:
            Created task details
        """
        try:
            team_tasks_file = self.memory_path / "shared" / "team_tasks.json"

            # Load existing tasks
            existing_tasks = []
            if team_tasks_file.exists():
                try:
                    with open(team_tasks_file, 'r') as f:
                        data = json.load(f)
                        existing_tasks = data.get("tasks", [])
                except:
                    pass

            # Create new task
            task = {
                "id": len(existing_tasks) + 1,
                "title": title,
                "description": description,
                "type": task_type,
                "priority": priority,
                "assigned_to": assigned_to,
                "estimated_hours": estimated_hours,
                "status": "planned",
                "created_at": datetime.now().isoformat(),
                "created_by": "CEO Agent"
            }

            existing_tasks.append(task)

            # Save updated tasks
            tasks_data = {
                "updated_at": datetime.now().isoformat(),
                "total_tasks": len(existing_tasks),
                "tasks": existing_tasks
            }

            with open(team_tasks_file, 'w') as f:
                json.dump(tasks_data, f, indent=2)

            self.log_activity("team_task_created", {
                "title": title,
                "type": task_type,
                "priority": priority,
                "assigned_to": assigned_to
            })

            return {
                "task_id": task["id"],
                "title": title,
                "type": task_type,
                "priority": priority,
                "assigned_to": assigned_to
            }

        except Exception as e:
            self.log_activity("create_team_task_error", {"title": title, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to create team task: {str(e)}")

    async def get_team_tasks(self, status_filter: Optional[str] = None,
                           assigned_to_filter: Optional[str] = None) -> Dict[str, Any]:
        """
        Get team tasks with optional filtering.

        Args:
            status_filter: Filter by status
            assigned_to_filter: Filter by assigned agent

        Returns:
            Filtered team tasks
        """
        try:
            team_tasks_file = self.memory_path / "shared" / "team_tasks.json"

            if not team_tasks_file.exists():
                return {
                    "tasks": [],
                    "total_tasks": 0,
                    "message": "No team tasks found"
                }

            with open(team_tasks_file, 'r') as f:
                data = json.load(f)

            tasks = data.get("tasks", [])

            # Apply filters
            if status_filter:
                tasks = [task for task in tasks if task.get("status") == status_filter]

            if assigned_to_filter:
                tasks = [task for task in tasks if task.get("assigned_to") == assigned_to_filter]

            return {
                "tasks": tasks,
                "total_tasks": len(tasks),
                "last_updated": data.get("updated_at"),
                "filters_applied": {
                    "status": status_filter,
                    "assigned_to": assigned_to_filter
                }
            }

        except Exception as e:
            self.log_activity("get_team_tasks_error", {"error": str(e)}, "error")
            raise MCPToolError(f"Failed to get team tasks: {str(e)}")

    async def update_project_status(self, status: str, description: str,
                                   completion_percentage: Optional[int] = None,
                                   blockers: List[str] = None) -> Dict[str, Any]:
        """
        Update overall project status.

        Args:
            status: Current status (planning, development, testing, deployment, completed)
            description: Status description
            completion_percentage: Overall completion percentage
            blockers: List of current blockers

        Returns:
            Updated status details
        """
        try:
            status_file = self.memory_path / "shared" / "project_status.json"

            status_data = {
                "status": status,
                "description": description,
                "completion_percentage": completion_percentage,
                "blockers": blockers or [],
                "last_updated": datetime.now().isoformat(),
                "updated_by": "CEO Agent"
            }

            with open(status_file, 'w') as f:
                json.dump(status_data, f, indent=2)

            self.log_activity("project_status_updated", {
                "status": status,
                "completion": completion_percentage,
                "blockers_count": len(blockers or [])
            })

            return {
                "status": status,
                "completion_percentage": completion_percentage,
                "blockers_count": len(blockers or []),
                "updated_at": datetime.now().isoformat()
            }

        except Exception as e:
            self.log_activity("update_status_error", {"status": status, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to update project status: {str(e)}")

    @openai_function("get_project_status", "Get current project status and completion information")
    async def get_project_status(self) -> Dict[str, Any]:
        """Get current project status."""
        try:
            status_file = self.memory_path / "shared" / "project_status.json"

            if not status_file.exists():
                return {
                    "status": "unknown",
                    "description": "No status information available",
                    "completion_percentage": 0,
                    "blockers": [],
                    "message": "Project status not initialized"
                }

            with open(status_file, 'r') as f:
                data = json.load(f)

            return data

        except Exception as e:
            self.log_activity("get_status_error", {"error": str(e)}, "error")
            raise MCPToolError(f"Failed to get project status: {str(e)}")

    @openai_function("create_progress_report", "Create comprehensive progress report for founder", {
        "type": "object",
        "properties": {
            "report_type": {"type": "string", "description": "Type of report", "enum": ["daily", "weekly", "monthly"], "default": "weekly"}
        }
    })
    async def create_progress_report(self, report_type: str = "weekly") -> Dict[str, Any]:
        """
        Create comprehensive progress report for founder.

        Args:
            report_type: Type of report (daily, weekly, monthly)

        Returns:
            Generated progress report
        """
        try:
            # Gather data for report
            project_status = await self.get_project_status()
            todo_list = await self.get_todo_list()
            team_tasks = await self.get_team_tasks()

            # Create report content
            report_content = f"""# {report_type.title()} Progress Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC
**Startup ID:** {self.startup_id}

## Executive Summary

**Current Status:** {project_status.get('status', 'Unknown')}
**Completion:** {project_status.get('completion_percentage', 0)}%

{project_status.get('description', 'No status description available')}

## Key Metrics

- **Total TODO Items:** {todo_list.get('total_items', 0)}
- **Team Tasks:** {team_tasks.get('total_tasks', 0)}
- **Active Blockers:** {len(project_status.get('blockers', []))}

## Current Priorities

"""
            # Add high priority todos
            high_priority_todos = [item for item in todo_list.get('items', [])
                                 if item.get('priority') == 'high' and item.get('status') != 'completed']

            if high_priority_todos:
                for todo in high_priority_todos[:5]:  # Top 5
                    report_content += f"- {todo['title']}\n"
            else:
                report_content += "- No high priority items identified\n"

            # Add blockers if any
            if project_status.get('blockers'):
                report_content += "\n## Current Blockers\n\n"
                for blocker in project_status['blockers']:
                    report_content += f"- {blocker}\n"

            report_content += f"\n## Next Steps\n\n"

            # Add planned team tasks
            planned_tasks = [task for task in team_tasks.get('tasks', [])
                           if task.get('status') == 'planned']

            if planned_tasks:
                for task in planned_tasks[:3]:  # Next 3 tasks
                    report_content += f"- {task['title']} (assigned to {task.get('assigned_to', 'TBD')})\n"
            else:
                report_content += "- No specific tasks planned\n"

            report_content += "\n---\n*Generated by CEO Agent*"

            # Save report
            report_filename = f"{report_type}_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            report_path = self.docs_path / report_filename

            with open(report_path, 'w') as f:
                f.write(report_content)

            self.log_activity("progress_report_created", {
                "report_type": report_type,
                "file_path": report_filename
            })

            return {
                "report_type": report_type,
                "file_path": report_filename,
                "content": report_content,
                "generated_at": datetime.now().isoformat()
            }

        except Exception as e:
            self.log_activity("create_report_error", {"report_type": report_type, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to create progress report: {str(e)}")

    async def add_team_message(self, message: str, channel: str = "general",
                              message_type: str = "info") -> Dict[str, Any]:
        """
        Add message to team communication channel.

        Args:
            message: Message content
            channel: Channel name (general, dev-updates, ceo-announcements)
            message_type: Message type (info, announcement, task, decision)

        Returns:
            Message posting result
        """
        try:
            channel_file = self.memory_path / "team_chat" / f"{channel}.jsonl"

            # Ensure team_chat directory exists
            channel_file.parent.mkdir(parents=True, exist_ok=True)

            message_data = {
                "timestamp": datetime.now().isoformat(),
                "author": "CEO Agent",
                "type": message_type,
                "content": message,
                "channel": channel
            }

            # Append to channel log
            with open(channel_file, 'a') as f:
                f.write(json.dumps(message_data) + "\n")

            self.log_activity("team_message_posted", {
                "channel": channel,
                "type": message_type,
                "message_length": len(message)
            })

            return {
                "channel": channel,
                "message_type": message_type,
                "posted_at": datetime.now().isoformat()
            }

        except Exception as e:
            self.log_activity("add_team_message_error", {"channel": channel, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to add team message: {str(e)}")

    async def get_team_messages(self, channel: str = "general",
                               last_n: int = 10) -> Dict[str, Any]:
        """
        Get recent team messages from channel.

        Args:
            channel: Channel name
            last_n: Number of recent messages to return

        Returns:
            Recent team messages
        """
        try:
            channel_file = self.memory_path / "team_chat" / f"{channel}.jsonl"

            if not channel_file.exists():
                return {
                    "channel": channel,
                    "messages": [],
                    "message": f"No messages found in {channel} channel"
                }

            messages = []
            with open(channel_file, 'r') as f:
                for line in f:
                    if line.strip():
                        try:
                            message = json.loads(line)
                            messages.append(message)
                        except:
                            pass

            # Return last N messages
            recent_messages = messages[-last_n:] if len(messages) > last_n else messages

            return {
                "channel": channel,
                "messages": recent_messages,
                "total_messages": len(messages),
                "showing_recent": len(recent_messages)
            }

        except Exception as e:
            self.log_activity("get_team_messages_error", {"channel": channel, "error": str(e)}, "error")
            raise MCPToolError(f"Failed to get team messages: {str(e)}")